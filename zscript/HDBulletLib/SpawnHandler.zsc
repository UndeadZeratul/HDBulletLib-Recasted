const HDCONST_HDBLEVENT = HDCONST_BPSPAWNPOOLEVENT + 1;

class HDBulletLibHandler : EventHandler {
    // [Ace] Order here must match bitshifting order in menudef and zscript files. - [Ted, UZ]
    static const class<HDAmmo> RemovedClasses[] = {
        'HDNDMLoose',
        'HDSlugAmmo',
        'HD500SWLightAmmo',
        'HD500SWHeavyAmmo',
        'HD50OMGAmmo',
        'HD45ACPAmmo',
        'HD10mAmmo',
        'HD45LCAmmo',
        'HDLLShellAmmo',
        'HDExplosiveShellAmmo',
        'HDGold45LCAmmo',
        'HDFlareAmmo',
        'HDBallAmmo',
        'HD4GSAmmo',
        'HD5mm_Ammo',
        'HD6mmFlechetteAmmo',
        'HD50AM_Ammo',
        'HDAurochsAmmo',
        'HD069BoreAmmo',
        'TenMilBrass',
        'Wan_ThuRKTAmmo',
        'Wan_TortRKTAmmo',
        'WAN_20mmGrenadeAmmo',
        'ThirtyAughtSixAmmo',
        'ThirtyAughtSixBrass',
        'HD4GBAmmo',
        'HDBirdshotShellAmmo',
        'Savage300Ammo',
        'HD762TokarevAmmo',
        'TokarevBrass',
        'Savage300Brass',
        'HD_776BeltLink', //[Eric] NOTE FOR FUTURE ADDITIONS: The first hdblib_enableammo CVAR is full as of this line. The next 32 entries below must use hdblib_enableammo_2.
        'HD_12MMBeltLink',
        'HD_35mmBeltLink'
    };

    // [Ace] Future-proofing. I doubt this library will ever have 32 * 3 ammo types and projectiles.
    private transient CVar AmmoSpawns[3];
    private HDAmBoxList AmmoBoxList;

    bool cvarsAvailable;

    // Populates the replacement and association arrays.
    void init() {

        cvarsAvailable = true;

        // Init enabled ammo CVARs
        for (let i = 0; i < 1 + RemovedClasses.Size() / 32; ++i) {
            if (!AmmoSpawns[i]) {
                AmmoSpawns[i] = CVar.GetCVar("hdblib_enableammo_"..(i + 1));
            }
        }
    }

    override void OnRegister() {
        SetOrder(HDCONST_HDBLEVENT);
    }

    override void WorldLoaded(worldevent e) {

        // Populates the main arrays if they haven't been already.
        if (!cvarsAvailable || !AmmoSpawns[0]) init();

        for (let i = 0; i < RemovedClasses.size(); i++) {
            if (!(AmmoSpawns[i / 32].GetInt() & (1 << (i % 32)))) {
                if (hd_debug) console.printf("Removing "..RemovedClasses[i].getClassName().." from Backpack Spawn Pool");

                BPSpawnPool.removeItem(RemovedClasses[i]);
            }
        }
    }

    override void WorldThingSpawned(WorldEvent e) {

        // Populates the main arrays if they haven't been already.
        if (!cvarsAvailable || !AmmoSpawns[0]) init();

        // [Ace] Only do it for the first ammo box encountered because they all share the same thinker.
        if (e.Thing is 'HDAmBox' && !AmmoBoxList) {
            AmmoBoxList = HDAmBoxList.Get();

            // Loop through all the names in the removed classes list.
            for (let i = 0; i < RemovedClasses.Size(); ++i) {

                // If we find the removed class in the AmmoBoxList, remove it
                if (!(AmmoSpawns[i / 32].GetInt() & (1 << (i % 32)))) {
                    int index = AmmoBoxList.InvClasses.Find(RemovedClasses[i].GetClassName());
                    if (index != AmmoBoxList.InvClasses.Size()) {
                        if (hd_debug) console.printf("Removing "..RemovedClasses[i].getClassName().." from Ammo Box Loot Table");

                        AmmoBoxList.InvClasses.Delete(index);
                    }
                }
            }
        }
    }

    private bool IsRemovedClass(class<HDAmmo> cls) {
        foreach (removedClass : RemovedClasses) if (cls == removedClass) return true;

        return false;
    }
}
